# Ray Tracing II

æ¥ä¸Šä¸€ç¯‡ `Ray Tracker I`ï¼Œ è¿™ä¸€ç¯‡æˆ‘ä¼šç»§ç»­ç¿»è¯‘ä»¥ä¸‹å‡ ä¸ªéƒ¨åˆ†ï¼š
- çƒçš„ç»˜åˆ¶
- æŠ—é”¯é½¿

## çƒçš„ç»˜åˆ¶

### æ³•çº¿

åœ¨ä¸Šä¸€ç¯‡çš„æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬è®²è¿°äº†å¦‚ä½•ç”Ÿæˆä¸€ä¸ªåœ†ï¼Œé‚£å¦‚ä½•ç»™è¿™ä¸ªåœ†æ·»åŠ é˜´å½±å‘¢ï¼Ÿè¿™å°±æ¶‰åŠåˆ°äº†`æ³•çº¿`ã€‚ä»€ä¹ˆæ˜¯æ³•çº¿ï¼Ÿç™¾ç§‘ä¸Šå¯¹å®ƒçš„è§£é‡Šæ˜¯ï¼š
> æ³•çº¿ï¼Œæ˜¯æŒ‡å§‹ç»ˆå‚ç›´äºæŸå¹³é¢çš„è™šçº¿ã€‚åœ¨æ•°å­¦å‡ ä½•ä¸­æ³•çº¿æŒ‡å¹³é¢ä¸Šå‚ç›´äºæ›²çº¿åœ¨æŸç‚¹çš„åˆ‡çº¿çš„ä¸€æ¡çº¿ã€‚

åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œçƒçš„æ³•çº¿æ˜¯å…‰çº¿æ’å‡»åˆ°çƒé¢çš„ä½ç½®å‡å»çƒå¿ƒçš„ä½ç½®

![normals](./images/fig-1-06-1.jpg)

æ¯”å¦‚åœ¨ä¸Šé¢çš„å›¾ä¸­ï¼Œæ³•çº¿ä¸º `N = P - C`ã€‚ æ¥ç€æˆ‘ä»¬å°±è¯•ç€æŠŠæ³•çº¿å¯è§†åŒ–å‡ºæ¥ã€‚ç”¨ä¼ªä»£ç è¡¨ç¤ºå°±æ˜¯ï¼š
```ts
N= Ray.point_at_parameter(t) - vec3(0,0,-1)
```
æ‰€ä»¥æˆ‘ä»¬éœ€è¦çŸ¥é“å…‰çº¿æ’å‡»åˆ°çƒä½“æ—¶çš„`t`çš„å€¼ã€‚

æˆ‘ä»¬åœ¨ä¸Šä¸€ç¯‡å·²ç»çŸ¥é“äº†å…³äºçƒçš„æ–¹ç¨‹ä¸å…‰çº¿çš„æ–¹ç¨‹ï¼Œå¹¶è”ç«‹å¾—å‡ºäº†ä¸€èˆ¬æ–¹ç¨‹ï¼š
> ğ‘¡^2â‹…ğ‘‘ğ‘œğ‘¡(ğµ,ğµ)+2ğ‘¡â‹…ğ‘‘ğ‘œğ‘¡(ğµ,ğ´âˆ’ğ¶)+ğ‘‘ğ‘œğ‘¡(ğ´âˆ’ğ¶,ğ´âˆ’ğ¶)âˆ’ğ‘…^2=0

é‚£ä¹ˆåœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°±å¯ä»¥åˆ©ç”¨æ±‚æ ¹çš„å…¬å¼æ±‚å‡º`t`çš„å€¼ã€‚ä¿®æ”¹`hit_sphere`çš„ä»£ç ä¸º:
```ts
function hit_sphere(center: vec3, radius: number, r: Ray) {
  // ğ‘¡2â‹…ğ‘‘ğ‘œğ‘¡(ğµ,ğµ)+2ğ‘¡â‹…ğ‘‘ğ‘œğ‘¡(ğµ,ğ´âˆ’ğ¶)+ğ‘‘ğ‘œğ‘¡(ğ´âˆ’ğ¶,ğ´âˆ’ğ¶)âˆ’ğ‘…2=0
  const oc: vec3 = Vec3.substract(r.origin(), center);
  const a = Vec3.dot(r.direction(), r.direction());
  const b = 2 * Vec3.dot(oc, r.direction());
  const c = Vec3.dot(oc, oc) - radius * radius;
  const discriminant = b * b - 4 * a * c;
  if (discriminant < 0) {
    return -1;
  }
  return (-b - Math.sqrt(discriminant)) / (2 * a);
}
```
åœ¨è¿™æ®µä»£ç é‡Œï¼Œå¦‚æœå…‰çº¿æ’å‡»åˆ°äº†çƒï¼Œé‚£ä¹ˆå°±æŠŠå…¶ä¸­çš„ä¸€ä¸ªè§£è¿”å›ï¼Œå¦åˆ™å°±è¿”å›`-1`ã€‚æ‹¿åˆ°`t`çš„å€¼ä¹‹åï¼Œå¸¦å…¥`N = P - C`åï¼Œæˆ‘ä»¬ä¾¿å¯ä»¥æ±‚å‡ºæ³•çº¿äº†ã€‚

### æ³•çº¿çš„å¯è§†åŒ–
æœ‰äº†æ³•çº¿ä¹‹åï¼Œä¾¿å¯ä»¥è¯•ç€å°†å®ƒå¯è§†åŒ–å‡ºæ¥ã€‚ä¸ºäº†æ–¹ä¾¿è®¡ç®—ï¼Œæˆ‘ä»¬æŠŠæ³•çº¿çš„é•¿åº¦å˜ä¸ºä¸€ä¸ªå•ä½ï¼Œæ‰€ä»¥å–å€¼æ˜¯[-1, 1], ä¸ºäº†æ˜ å°„åˆ°`RGB`çš„å€¼ï¼Œæˆ‘ä»¬å†æŠŠæ³•çº¿æ˜ å°„åˆ°[0, 1]çš„åŒºé—´ã€‚è¿™æ—¶å€™æ³•çº¿`(x, y, z)`ä¾¿å¯ä»¥æ˜ å°„ä¸º`(r, g, b)`, ä¿®æ”¹æˆ‘ä»¬ä¹‹å‰çš„`color` çš„ä»£ç :
```ts
function color(ray: Ray): vec3 {
  let t = hit_sphere(Vec3.create(0, 0, -1), 0.5, ray);
  // hited
  if (t > 0) {
    // N = P - C
    const N: vec3 = Vec3.unit_vector(
      Vec3.substract(ray.point_at_parameter(t), Vec3.create(0, 0, -1))
    );
    // Map (-1, 1) => (0, 1)
    return Vec3.multiply(
      Vec3.create(Vec3.x(N) + 1, Vec3.y(N) + 1, Vec3.z(N) + 1),
      0.5
    );
  }
  // unit vector(a) = A / |A|
  const unit_direction: vec3 = Vec3.unit_vector(ray.direction());
  t = 0.5 * (Vec3.y(unit_direction) + 1);
  // ğ‘ğ‘™ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘‘ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’=(1âˆ’ğ‘¡)âˆ—ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’+ğ‘¡âˆ—ğ‘’ğ‘›ğ‘‘ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’,
  // when t = 1.0 => blue, when t = 0 => white
  return Vec3.add(
    Vec3.multiply([1.0, 1.0, 1.0], 1.0 - t),
    Vec3.multiply([0.5, 0.7, 1.0], t)
  );
}
```
å¦‚æ­¤ï¼Œä¾¿æŠŠæ³•çº¿è¿›è¡Œäº†å¯è§†åŒ–, æ³•çº¿æè¿°äº†å…‰çº¿çš„æ’å‡»ç‚¹ä¸çƒå¿ƒçš„å…³ç³»ï¼Œä¹‹åä¾¿å¯ä»¥åˆ©ç”¨è¿™ä¸ªå…³ç³»ä½œå‡ºå¤šç§å¯è§†åŒ–æ•ˆæœã€‚æš‚æ—¶å…ˆåªæ˜¯ç®€å•çš„åšä¸€ä¸ªæ˜ å°„ã€‚

![v](./images/img-1-06-1.jpg)

### ç»˜åˆ¶å¤šä¸ªåœ†

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªæ˜¯ç”»äº†ä¸€ä¸ªçƒä½“ï¼Œé‚£å¦‚æœè¦ç”»å‡ºå¤šä¸ªçƒä½“è¯¥å¦‚ä½•åšå‘¢ï¼Ÿæˆ‘ä»¬å¾ˆå½“ç„¶çš„æƒ³åˆ°ï¼Œå¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ª`sphere`çš„ç±»ï¼Œéœ€è¦çš„æ—¶å€™`new`ä¸€ä¸ªå®ä¾‹ä¾¿å¯ä»¥äº†ã€‚é‚£è¿™ä¸ª`sphere`éƒ½æ˜¯ä¼šè¢«å…‰çº¿æ•è·çš„ï¼Œåªæœ‰å…‰çº¿ç…§å°„åœ¨çƒä¸Šæ—¶ï¼Œçƒæ‰èƒ½è¢«çœ‹åˆ°ï¼Œæ‰€ä»¥å®ƒä¼šæœ‰ä¸€ä¸ª`hit`æ¥å¯¹å…‰çº¿è¿›è¡Œå¤„ç†ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ª`abstract class` æ¥è®©`sphere`ç»§æ‰¿ã€‚
```ts
export type hit_record = {
  t: number;
  p: vec3;
  normal: vec3;
};

export abstract class hittable {
  hit: (
    r: Ray,
    t_min: number,
    t_max: number,
    hit_record: hit_record
  ) => boolean;
}
```
è¿™é‡Œéœ€è¦å®šä¹‰ä¸ª`hit_record`çš„è®°å½•é¡¹ï¼Œä¸€ä½†å…‰çº¿æ’å‡»åˆ°äº†çƒä½“ï¼Œæˆ‘ä»¬éœ€è¦è®°å½•ä¸‹å½“å‰è¿™æŸå…‰çº¿çš„`t`å€¼ï¼Œæ’å‡»ä½ç½®`p`ï¼Œ å·²ç»å¯¹äºçš„æ³•çº¿`normal`ã€‚å¤§å¤šæ•°çš„å…‰çº¿è¿½è¸ªçš„ä»£ç é‡Œï¼Œéƒ½ä¼šå¯¹`t`è¿›è¡Œæ ¡éªŒï¼Œåªæœ‰  `t_min < t < t_max` æ—¶ä¼šå¯¹å…‰çº¿è¿›è¡Œåˆ¤æ–­ã€‚

ç„¶åæˆ‘ä»¬å»å®ç°è¿™ä¸ª`hit`æ–¹æ³•ã€‚ å°±æ˜¯æŠŠä¹‹å‰çš„`hit_sphere`æ–¹æ³•æ”¾åˆ°`hit`é‡Œé¢
```ts
export class Sphere implements hittable {
  center: vec3;
  radius: number;
  constructor(props: Props) {
    this.center = props.center;
    this.radius = props.radius;
  }
  hit(r: Ray, t_min: number, t_max: number, rec: hit_record) {
    const { center, radius } = this;
    // ğ‘¡2â‹…ğ‘‘ğ‘œğ‘¡(ğµ,ğµ)+2ğ‘¡â‹…ğ‘‘ğ‘œğ‘¡(ğµ,ğ´âˆ’ğ¶)+ğ‘‘ğ‘œğ‘¡(ğ´âˆ’ğ¶,ğ´âˆ’ğ¶)âˆ’ğ‘…2=0
    const oc: vec3 = Vec3.substract(r.origin(), center);
    const a = Vec3.dot(r.direction(), r.direction());
    const b = 2 * Vec3.dot(oc, r.direction());
    const c = Vec3.dot(oc, oc) - radius * radius;
    const discriminant = b * b - 4 * a * c;
    if (discriminant > 0) {
      let temp = (-b - Math.sqrt(discriminant)) / (2 * a);
      if (temp < t_max && temp > t_min) {
        rec.t = temp;
        rec.p = r.point_at_parameter(rec.t);
        rec.normal = Vec3.unit_vector(Vec3.substract(rec.p, center));
        return true;
      }
      temp = (-b + Math.sqrt(discriminant)) / (2 * a);
      if (temp < t_max && temp > t_min) {
        rec.t = temp;
        rec.p = r.point_at_parameter(rec.t);
        rec.normal = Vec3.unit_vector(Vec3.substract(rec.p, center));
        return true;
      }
    }
    return false;
  }
}
```

ä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ª`Hittable_list`æ¥æŠŠæ‰€æœ‰çš„`sphere`ç®¡ç†èµ·æ¥, å½“æˆä¸€ä¸ª`scence`ã€‚
```ts
export class Hittable_list implements hittable {
  list: hittable[];
  list_size: number;
  constructor(props: Props) {
    this.list = props.l;
    this.list_size = props.n;
  }

  hit(r: Ray, t_min: number, t_max: number, rec: hit_record) {
    let temp_rec: hit_record = {
      t: 0,
      p: Vec3.create(),
      normal: Vec3.create()
    };
    let hit_anything = false;
    let closest_so_far = t_max;
    for (let i = 0; i < this.list_size; i++) {
      if (this.list[i].hit(r, t_min, closest_so_far, temp_rec)) {
        hit_anything = true;
        closest_so_far = temp_rec.t;
        rec.normal = temp_rec.normal;
        rec.p = temp_rec.p;
        rec.t = temp_rec.t;
      }
    }
    return hit_anything;
  }
}
```

è¿™æ ·ä¹‹åï¼Œä¾¿å¯ä»¥åœ¨éœ€è¦çš„æ—¶å€™ï¼Œä¸ºä¸€ä¸ª`scence`åˆ›å»ºå¤šä¸ªçƒä½“
```ts
  const list: hittable[] = [
    new Sphere({ center: Vec3.create(0, 0, -1), radius: 0.5 }),
    new Sphere({ center: Vec3.create(0, -100.5, -1), radius: 100 })
  ];

  const world: hittable = new Hittable_list({ l: list, n: 2 });
```
æ•ˆæœå¯ä»¥çœ‹ä¸‹é¢çš„å›¾ç‰‡ï¼š

![multiple](./images/img-1-06-2.jpg)

å¦‚æ­¤æˆ‘ä»¬ä¾¿åœ¨ä¸€ä¸ªåœºæ™¯é‡Œç»˜åˆ¶äº†å¤šä¸ªçƒã€‚å¯ä»¥çœ‹åˆ°çƒä½“çš„è¡¨é¢å·²ç»æœ‰äº†é¢œè‰²ï¼Œè¿™ä¾¿æ˜¯æ³•çº¿çš„å€¼è¢«æ˜ å°„æˆRGBæ‰€äº§ç”Ÿçš„é¢œè‰²ã€‚

## æŠ—é”¯é½¿
å¦‚æœæ”¾å¤§ä¸Šé¢çš„å›¾ç‰‡ï¼Œæˆ‘ä»¬ä¼šå‘ç°çƒçš„è¾¹ç¼˜æ˜¯æœ‰æ˜æ˜¾çš„é”¯é½¿çš„ã€‚ä½†æ˜¯åœ¨æˆ‘ä»¬ç”¨ç…§ç›¸æœºæ¥æ‹æ‘„ä¸€å¼ ç…§ç‰‡çš„æ—¶å€™ï¼Œåœ¨å›¾åƒçš„è¾¹ç¼˜é€šå¸¸çœ‹èµ·æ¥æ˜¯å¹³æ»‘çš„ï¼Œè¿™æ˜¯å› ä¸ºé”¯é½¿è¢«æ··åœ¨èƒŒæ™¯æˆ–è€…å‰æ™¯é‡Œäº†ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªç®€å•çš„æ–¹æ³•æ¥æ¨¡æ‹Ÿè¿™ç§æ•ˆæœï¼šåœ¨æ±‚ä¸€ä¸ªåƒç´ çš„rgbå€¼çš„æ—¶å€™ï¼Œå¯ä»¥å–è¯¥åƒç´ é™„è¿‘çš„100ä¸ªåƒç´ ä½œä¸ºæ ·æœ¬ï¼Œç„¶åæ±‚è¿™100ä¸ªæ ·æœ¬çš„å¹³å±€å€¼ä½œä¸ºè¯¥åƒç´ çš„å€¼ï¼Œæ‰€ä»¥æ”¹é€ ä¹‹å‰`main`å‡½æ•°é‡Œçš„ä»£ç ï¼š
```ts
  // const nx = 200;
  // const ny = 100;
  // const ns = 100;
  for (let j = ny - 1; j >= 0; j--) {
    for (let i = 0; i < nx; i++) {
      let col = Vec3.create();
      for (let s = 0; s < ns; s++) {
        const u = (i + Math.random()) / nx;
        const v = (j + Math.random()) / ny;
        const r = cam.get_ray(u, v); // Camera instance
        col = Vec3.add(col, color(r, world));
      }
      col = Vec3.devide(col, ns);

      const ir = Math.floor(255.99 * col[0]);
      const ig = Math.floor(255.99 * col[1]);
      const ib = Math.floor(255.99 * col[2]);
      stream.write(`${ir} ${ig} ${ib}\n`);
    }
  }
```
åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä¹ŸæŠŠå®šä¹‰äº†ä¸€ä¸ª`Camera`çš„ç±»ï¼Œé€šè¿‡è¿™ä¸ªç±»æ¥è·å–å…‰çº¿
```ts
export class Camera {
  lower_left_corner: vec3;
  horizontal: vec3;
  vertical: vec3;
  origin: vec3;

  constructor(l: vec3, h: vec3, v: vec3, o: vec3) {
    this.lower_left_corner = l;
    this.horizontal = h;
    this.vertical = v;
    this.origin = o;
  }

  get_ray(u: number, v: number): Ray {
    const { origin, lower_left_corner, horizontal, vertical } = this;
    // lower_left_corner + u*horizontal + v*vertical - origin
    const direction = Vec3.substract(
      Vec3.add(
        Vec3.add(lower_left_corner, Vec3.multiply(horizontal, u)),
        Vec3.multiply(vertical, v)
      ),
      origin
    );
    return new Ray(origin, direction);
  }
}
```
é€šè¿‡å–å‡å€¼çš„åŠæ³•æ¥ä½¿å¾—è¾¹ç¼˜æ›´å¥½çš„èå…¥å‘¨å›´çš„é¢œè‰²å½“ä¸­ï¼Œåœ¨è§†è§‰ä¸Šä¾¿èµ·åˆ°äº†å¹³æ»‘è¿‡æ¸¡çš„æ•ˆæœã€‚

åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬ä»‹ç»äº†å¦‚ä½•ç»˜åˆ¶å¤šä¸ªå¯¹è±¡ï¼Œå¹¶ä¸”åˆ©ç”¨æ±‚å‡å€¼æ³•æ¥è¿›è¡Œé”¯é½¿çš„ä¿®å¤ã€‚





